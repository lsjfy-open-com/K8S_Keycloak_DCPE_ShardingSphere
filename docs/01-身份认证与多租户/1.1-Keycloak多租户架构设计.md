# 1.1 Keycloak多租户架构设计

## 1.1.1 概述

本节详细描述基于Keycloak的多租户身份认证架构设计，包括Realm规划、租户隔离策略和Client Scope配置。

## 1.1.2 Realm设计策略

### 方案A：每个租户一个Realm

**优点**：
- 隔离性最好，配置清晰
- 租户间完全独立
- 便于单独管理

**缺点**：
- Realm数量多，运维复杂
- 资源消耗大
- 统一策略管理困难

**适用场景**：租户数量少（<10），隔离要求极高

### 方案B：一个Realm，多个Client（推荐）

**优点**：
- 资源利用率高
- 运维复杂度低
- 易于统一管理
- 策略复用性好

**缺点**：
- 隔离性相对较低
- 需要仔细设计Client Scope
- 权限配置复杂度高

**适用场景**：租户数量多（>10），资源共享需求

### 推荐方案B实现

#### Realm结构

```
Master Realm（管理域）
├── Client: tenant-management（租户管理）
├── Client: app-gateway（应用网关）
└── Client Scopes:
    ├── tenant-common（租户通用属性）
    ├── tenant-a-attributes（租户A特定属性）
    └── tenant-b-attributes（租户B特定属性）

Tenant A Realm（租户A专属域）
├── Client: tenant-a-app
└── Roles: admin, user, readonly

Tenant B Realm（租户B专属域）
├── Client: tenant-b-app
└── Roles: admin, user, readonly
```

## 1.1.3 租户识别机制

### 方式1：基于域名
```java
public String identifyTenantByDomain(String host) {
    // 从域名中提取租户标识
    // 例如：tenant-a.app.com -> tenant-a
    String tenantId = extractSubdomain(host);
    return tenantId;
}
```

### 方式2：基于请求头
```java
public String identifyTenantByHeader(HttpServletRequest request) {
    String tenantHeader = request.getHeader("X-Tenant-ID");
    if (tenantHeader != null) {
        return tenantHeader;
    }
    throw new TenantIdentificationException("租户标识不存在");
}
```

### 方式3：基于邮箱后缀
```java
public String identifyTenantByEmail(String email) {
    // 例如：user@tenant-a.com -> tenant-a
    String domain = email.substring(email.indexOf('@') + 1);
    String tenantId = extractTenantFromDomain(domain);
    return tenantId;
}
```

### 完整实现
```java
public class TenantIdentificationService {
    
    public String identifyTenant(HttpServletRequest request) {
        // 方式1：基于域名
        String host = request.getServerName();
        String tenantId = extractTenantFromDomain(host);
        if (tenantId != null) {
            return tenantId;
        }
        
        // 方式2：基于请求头
        String tenantHeader = request.getHeader("X-Tenant-ID");
        if (tenantHeader != null) {
            return tenantHeader;
        }
        
        // 方式3：基于邮箱后缀
        String token = extractToken(request);
        String email = extractEmailFromToken(token);
        String tenantId = extractTenantFromEmail(email);
        if (tenantId != null) {
            return tenantId;
        }
        
        throw new TenantIdentificationException("无法识别租户");
    }
}
```

## 1.1.4 Client Scope配置

### 配置示例
```json
{
  "name": "tenant-isolation",
  "description": "租户数据隔离",
  "protocol": "openid-connect",
  "attributes": {
    "include.in.token.scope": "true",
    "signing.alg": "RS256"
  },
  "protocolMappers": [
    {
      "name": "tenant-id-mapper",
      "protocol": "openid-connect",
      "protocolMapper": "oidc-hardcoded-claim-id-token-mapper",
      "config": {
        "claim.name": "tenant_id",
        "claim.value": "${client.clientId}",
        "access.token.claim": "true",
        "id.token.claim": "true"
      }
    }
  ]
}
```

## 1.1.5 权限策略配置

### 策略配置示例
```json
{
  "policies": [
    {
      "name": "tenant-data-policy",
      "description": "租户数据隔离策略",
      "type": "client",
      "logic": "POSITIVE",
      "decisionStrategy": "UNANIMOUS",
      "config": {
        "clients": "${client.clientId}",
        "roles": "user",
        "allow": "true"
      }
    }
  ]
}
```

## 1.1.6 部署配置

### K8s部署配置
```yaml
# keycloak-deployment.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: keycloak
  namespace: auth
spec:
  serviceName: keycloak-headless
  replicas: 3
  selector:
    matchLabels:
      app: keycloak
  template:
    metadata:
      labels:
        app: keycloak
    spec:
      containers:
      - name: keycloak
        image: quay.io/keycloak/keycloak:23.0.0
        args: ["start", "--optimized"]
        env:
        - name: KEYCLOAK_ADMIN
          value: "admin"
        - name: KEYCLOAK_ADMIN_PASSWORD
          valueFrom:
            secretKeyRef:
              name: keycloak-admin
              key: password
        ports:
        - name: http
          containerPort: 8080
        - name: https
          containerPort: 8443
        resources:
          requests:
            cpu: "500m"
            memory: "1Gi"
          limits:
            cpu: "2000m"
            memory: "4Gi"
```

## 1.1.7 交付物清单

- [ ] 架构设计文档（PDF）
- [ ] Keycloak集群部署方案
- [ ] 多租户认证流程图
- [ ] Realm规划文档
- [ ] Client Scope配置示例
- [ ] 权限策略配置文档

## 1.1.8 验收标准

- [ ] Keycloak集群可用
- [ ] 管理控制台可访问
- [ ] 能够创建Realm和Client
- [ ] 租户识别机制正常工作
- [ ] Client Scope配置生效
- [ ] 权限策略正常工作

## 1.1.9 工时估算

| 任务 | 工时 |
|-----|------|
| Realm设计 | 3人天 |
| 租户识别实现 | 4人天 |
| Client Scope配置 | 3人天 |
| 权限策略配置 | 2人天 |
| 部署配置 | 2人天 |
| 测试验证 | 4人天 |
| **总计** | **18人天** |

## 1.1.10 相关文档

- [AD集成与身份映射](./1.2-AD集成与身份映射.md)
- [部署配置](./部署配置/keycloak-deployment.yaml)
- [主项目文档](../项目工作分解结构.md)
