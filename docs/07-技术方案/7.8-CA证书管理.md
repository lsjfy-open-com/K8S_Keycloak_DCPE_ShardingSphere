# 7.8 CA证书管理

## 7.8.1 证书管理架构

### 设计原则
1. **内部不使用CA**：简化架构，减少维护复杂度
2. **Keycloak客户端认证**：使用客户端凭证而非证书认证
3. **证书由客户根CA签发**：符合企业安全合规要求
4. **提供UI替换界面**：傻瓜式操作，降低客户门槛

### 证书类型
| 证书类型 | 用途 | 签发方 | 替换频率 |
|---------|------|--------|---------|
| 入口证书 | Kong网关HTTPS | 客户根CA | 每年 |
| 服务证书 | mTLS通信 | 客户根CA | 每年 |
| 数据库证书 | 数据库连接 | 客户根CA | 每年 |
| Vault证书 | Vault HTTPS | 客户根CA | 每年 |

## 7.8.2 内部服务认证方案

### Keycloak客户端凭证认证

由于内部不使用CA，采用Keycloak的客户端凭证（Client Credentials）模式进行服务间认证：

```yaml
# 客户端凭证配置
clients:
  - clientId: "app-service"
    secret: "${CLIENT_SECRET}"
    clientAuthenticatorType: "client-secret"
    standardFlowEnabled: false
    serviceAccountsEnabled: true
    publicClient: false
    protocol: "openid-connect"
```

### 服务间认证流程
```
服务A → Keycloak (Client Credentials) → 获取Token → 访问服务B
```

### 内部mTLS方案

对于需要mTLS的场景，使用预签发的服务证书：

```yaml
# 服务mTLS配置
apiVersion: v1
kind: Secret
metadata:
  name: service-tls
type: kubernetes.io/tls
data:
  tls.crt: <base64-encoded-cert>
  tls.key: <base64-encoded-key>
```

## 7.8.3 证书管理UI设计

### 证书管理界面功能

```typescript
// CertificateManagementUI.tsx
interface CertificateManagementUIProps {
  // 证书列表
  certificates: Certificate[];
  
  // 上传证书
  onUpload: (cert: CertificateUploadRequest) => Promise<void>;
  
  // 替换证书
  onReplace: (certId: string, newCert: CertificateUploadRequest) => Promise<void>;
  
  // 验证证书
  onValidate: (certId: string) => Promise<ValidationResult>;
}

class CertificateManagementUI {
  // 证书列表页面
  renderCertificateList() {
    return (
      <div className="certificate-list">
        <table>
          <thead>
            <tr>
              <th>证书名称</th>
              <th>类型</th>
              <th>到期日期</th>
              <th>状态</th>
              <th>操作</th>
            </tr>
          </thead>
          <tbody>
            {this.certificates.map(cert => (
              <tr key={cert.id}>
                <td>{cert.name}</td>
                <td>{cert.type}</td>
                <td>{cert.expiryDate}</td>
                <td>
                  <StatusBadge status={cert.status} />
                </td>
                <td>
                  <Button onClick={() => this.handleReplace(cert.id)}>
                    替换证书
                  </Button>
                  <Button onClick={() => this.handleValidate(cert.id)}>
                    验证
                  </Button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    );
  }
  
  // 证书上传/替换表单
  renderCertificateForm(certificate: Certificate) {
    return (
      <div className="certificate-form">
        <h3>替换证书 - {certificate.name}</h3>
        
        <Form onSubmit={this.handleSubmit}>
          <Form.Item label="证书文件 (.crt)">
            <Upload
              accept=".crt,.pem"
              beforeUpload={this.validateCertificateFile}
            >
              <Button icon={<UploadOutlined />}>
                上传证书
              </Button>
            </Upload>
          </Form.Item>
          
          <Form.Item label="私钥文件 (.key)">
            <Upload
              accept=".key,.pem"
              beforeUpload={this.validatePrivateKeyFile}
            >
              <Button icon={<UploadOutlined />}>
                上传私钥
              </Button>
            </Upload>
          </Form.Item>
          
          <Form.Item label="CA证书 (.crt)">
            <Upload
              accept=".crt,.pem"
              beforeUpload={this.validateCAFile}
            >
              <Button icon={<UploadOutlined />}>
                上传CA证书
              </Button>
            </Upload>
          </Form.Item>
          
          <Alert
            message="注意"
            description="证书替换将导致服务短暂中断，建议在维护窗口期操作"
            type="warning"
          />
          
          <Form.Item>
            <Button type="primary" htmlType="submit">
              确认替换
            </Button>
            <Button onClick={this.handleCancel}>
              取消
            </Button>
          </Form.Item>
        </Form>
      </div>
    );
  }
}
```

### 证书验证逻辑

```python
class CertificateValidator:
    def validate_certificate(self, cert_file: str, key_file: str, ca_file: str = None) -> ValidationResult:
        """
        验证证书有效性
        """
        result = ValidationResult()
        
        try:
            # 1. 加载证书
            cert = self.load_certificate(cert_file)
            
            # 2. 验证证书格式
            if not self.is_valid_format(cert):
                result.add_error("证书格式无效")
                return result
            
            # 3. 验证私钥匹配
            key = self.load_private_key(key_file)
            if not self.check_key_match(cert, key):
                result.add_error("证书与私钥不匹配")
                return result
            
            # 4. 验证证书有效期
            if not self.is_valid_date(cert):
                result.add_error("证书已过期或未生效")
                return result
            
            # 5. 验证CA签名（如果提供了CA证书）
            if ca_file:
                ca_cert = self.load_certificate(ca_file)
                if not self.verify_signature(cert, ca_cert):
                    result.add_error("证书签名验证失败")
                    return result
            
            # 6. 验证域名匹配（如果适用）
            if not self.verify_hostname(cert):
                result.add_warning("证书域名与服务不匹配")
            
            result.success = True
            result.message = "证书验证通过"
            
        except Exception as e:
            result.add_error(f"验证过程出错: {str(e)}")
        
        return result
```

## 7.8.4 证书管理后端API

### API接口设计

```yaml
# Certificate Management API
paths:
  /api/v1/certificates:
    get:
      summary: 获取证书列表
      responses:
        200:
          description: 证书列表
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Certificate'
    
    post:
      summary: 上传新证书
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                name:
                  type: string
                type:
                  type: string
                  enum: [ingress, service, database, vault]
                certFile:
                  type: string
                  format: binary
                keyFile:
                  type: string
                  format: binary
                caFile:
                  type: string
                  format: binary

  /api/v1/certificates/{id}/replace:
    post:
      summary: 替换证书
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                certFile:
                  type: string
                  format: binary
                keyFile:
                  type: string
                  format: binary
                caFile:
                  type: string
                  format: binary

  /api/v1/certificates/{id}/validate:
    get:
      summary: 验证证书
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        200:
          description: 验证结果
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ValidationResult'
```

### 证书替换服务

```python
class CertificateReplacementService:
    def __init__(self, k8s_client, vault_client):
        self.k8s_client = k8s_client
        self.vault_client = vault_client
    
    async def replace_certificate(self, cert_id: str, new_cert: CertificateUploadRequest) -> ReplaceResult:
        """
        替换证书的完整流程
        """
        result = ReplaceResult()
        
        try:
            # 1. 验证新证书
            validation = self.validator.validate_certificate(
                new_cert.cert_file,
                new_cert.key_file,
                new_cert.ca_file
            )
            
            if not validation.success:
                result.errors = validation.errors
                return result
            
            # 2. 备份当前证书
            backup = await self.backup_current_certificate(cert_id)
            result.backup = backup
            
            # 3. 上传新证书到K8s Secret
            await self.upload_to_k8s_secret(cert_id, new_cert)
            
            # 4. 更新相关服务配置
            await self.update_service_config(cert_id, new_cert)
            
            # 5. 重启相关服务
            await self.restart_services(cert_id)
            
            # 6. 验证服务健康
            health_check = await self.verify_service_health(cert_id)
            
            if not health_check.healthy:
                # 回滚
                await self.rollback(cert_id, backup)
                result.add_error("服务健康检查失败，已回滚")
                return result
            
            result.success = True
            result.message = "证书替换成功"
            
        except Exception as e:
            # 发生异常时回滚
            await self.rollback(cert_id, backup)
            result.add_error(f"证书替换失败: {str(e)}")
        
        return result
    
    async def rollback(self, cert_id: str, backup: CertificateBackup):
        """
        回滚证书替换
        """
        # 恢复备份的证书
        await self.restore_from_backup(cert_id, backup)
        
        # 重启服务
        await self.restart_services(cert_id)
```

## 7.8.5 内部服务账户管理

### 服务账户类型

| 账户类型 | 用途 | 管理方式 |
|---------|------|---------|
| 数据库账户 | 应用访问数据库 | Vault动态凭证 |
| API密钥 | 服务间调用 | Keycloak客户端 |
| K8s ServiceAccount | Pod间通信 | K8s原生管理 |
| Vault令牌 | 密钥访问 | Vault动态密钥 |

### 数据库账户管理

```yaml
# Vault数据库动态凭证配置
apiVersion: secrets.hashicorp.com/v1beta1
kind: VaultDynamicSecret
metadata:
  name: gaussdb-credentials
spec:
  namespace: default
  mount: database
  objectName: gaussdb-role
  destination:
    create: true
    name: gaussdb-app-credentials
    type: kubernetes.io/opaque
```

### 服务间认证配置

```yaml
# Keycloak客户端配置
clients:
  - clientId: "order-service"
    secret: "${ORDER_SERVICE_SECRET}"
    serviceAccountsEnabled: true
    standardFlowEnabled: false
    directAccessGrantsEnabled: true
    
  - clientId: "payment-service"
    secret: "${PAYMENT_SERVICE_SECRET}"
    serviceAccountsEnabled: true
    standardFlowEnabled: false
    directAccessGrantsEnabled: true

# 服务间访问策略
authorizationPolicies:
  - name: "service-access-policy"
    rules:
      - from: "order-service"
        to: "payment-service"
        allow: true
```

### 账户安全策略

```yaml
# 账户安全策略
securityPolicies:
  - name: "password-policy"
    rules:
      - minLength: 32
      - requireUppercase: true
      - requireLowercase: true
      - requireNumbers: true
      - requireSpecialChars: true
      - maxAge: 90d
  
  - name: "rotation-policy"
    rules:
      - database-credentials:
          rotationPeriod: 30d
          autoRotate: true
      - api-keys:
          rotationPeriod: 90d
          autoRotate: true
      - service-accounts:
          rotationPeriod: 365d
          autoRotate: true
```

## 7.8.6 证书管理操作手册

### 日常操作流程

#### 1. 证书查看
```bash
# 查看所有证书状态
kubectl get certificates -A

# 查看证书详情
kubectl describe certificate ingress-tls -n default

# 检查证书到期时间
openssl x509 -enddate -noout -in /path/to/cert.crt
```

#### 2. 证书替换步骤
1. 登录证书管理UI
2. 选择需要替换的证书
3. 上传新证书文件
4. 系统自动验证证书
5. 确认替换（注意警告信息）
6. 系统自动更新K8s Secret
7. 自动重启相关服务
8. 验证服务健康状态

#### 3. 紧急回滚
如果证书替换后服务异常：
1. 在证书管理UI中找到该证书
2. 点击"回滚"按钮
3. 系统自动恢复备份证书
4. 重启服务
5. 验证服务恢复

## 7.8.7 相关文档

- [安全架构](./7.5-安全架构.md)
- [客户IT沟通方案](./7.7-客户IT沟通方案.md)
- [部署拓扑](./7.4-部署拓扑.md)
