# K8s多Pod应用客户环境部署项目 - 工作分解结构

## 项目概述

### 项目背景
将内部K8s多Pod应用部署到客户环境，涉及多模型部署、关系数据库服务、向量数据库和内部多微服务相互调用。

### 技术栈
- **身份认证**：Keycloak OAuth2/OIDC
- **向量数据库**：Milvus（仅存储表头和非内容性数据）
- **关系数据库**：高斯数据库（GaussDB）
- **容器编排**：Kubernetes多Pod部署
- **身份源**：客户Active Directory（AD）

### 核心挑战
1. 对接客户AD实现多租户认证和授权
2. K8s Secret保护身份映射和数据库账号信息
3. 在不修改客户表结构的情况下实现表级和列级访问控制
4. Keycloak多租户gateway和策略模块实现

---

## 工作分解结构（WBS）

### 第一大类：身份认证与多租户架构（2人负责）

#### 1.1 Keycloak多租户架构设计（负责人：身份认证架构师）
**工作内容**：
- 客户AD架构调研和现有权限模型分析
- 多租户认证流程设计
- Realm规划与租户隔离策略设计
- Keycloak版本选择与集群方案设计
- 架构设计文档编写

**技术要点**：
- Realm设计策略（单Realm多Client vs 多Realm）
- Client Scope实现租户数据隔离
- 基于Client的访问策略配置
- 租户识别机制（域名/邮箱后缀/请求头）

**交付物**：
- 架构设计文档（PDF）
- Keycloak集群部署方案
- 多租户认证流程图
- Realm规划文档

#### 1.2 AD集成与身份映射（负责人：安全工程师）
**工作内容**：
- LDAP/AD Federation配置
- 用户属性映射规则设计
- 租户识别逻辑实现
- AD组到应用角色的映射
- 跨租户会话管理

**技术要点**：
- Keycloak LDAP/AD Federation Provider配置
- 用户联合会话管理
- 组-角色映射策略
- 属性同步与缓存策略

**交付物**：
- AD集成配置文档
- 身份映射规则配置
- 角色映射矩阵
- 会话管理方案

---

### 第二大类：K8s安全与Secret管理（1人负责）

#### 2.1 K8s Secret安全方案（负责人：安全工程师）
**工作内容**：
- K8s Secret静态加密配置
- 密钥自动轮换策略设计
- RBAC访问控制配置
- Secret访问审计日志
- 外部密钥管理系统集成（Vault/KMS）
- Secret备份恢复方案

**技术要点**：
- K8s Secret加密配置（encryption at rest）
- HashiCorp Vault集成方案
- Service Account最小权限原则
- Secret版本管理
- 网络隔离策略

**交付物**：
- Secret安全配置文档
- 密钥轮换策略文档
- RBAC配置清单
- Vault集成方案
- 备份恢复方案

---

### 第三大类：数据访问控制层（2人负责）

#### 3.1 访问控制引擎（负责人：数据安全工程师）
**工作内容**：
- Apache ShardingSphere Proxy部署与配置
- OPA（Open Policy Agent）策略引擎集成
- 数据脱敏规则配置
- 访问策略定义与管理
- 统一访问控制API设计

**技术要点**：
- ShardingSphere数据脱敏（Column Masking）
- OPA Rego策略语言
- 策略即代码（Policy as Code）
- 策略缓存与性能优化
- API接口设计（RESTful）

**交付物**：
- ShardingSphere部署配置
- OPA策略配置
- 数据脱敏规则文档
- API接口文档
- 策略管理平台

#### 3.2 ODBC数据访问层（负责人：数据访问工程师）
**工作内容**：
- 通用ODBC数据访问组件开发
- ShardingSphere JDBC集成
- 数据库连接池管理
- 异常处理与日志记录
- 查询性能优化与批处理

**技术要点**：
- ODBC驱动封装
- ShardingSphere JDBC连接配置
- 连接池配置（HikariCP）
- 参数化查询防止SQL注入
- 批处理事务管理

**交付物**：
- ODBC组件源代码
- ShardingSphere集成配置
- 连接池配置文档
- 异常处理规范
- API使用文档

---

### 第四大类：Milvus与向量数据库集成（1人负责）

#### 4.1 向量数据库部署与集成（负责人：向量数据库工程师）
**工作内容**：
- Milvus K8s部署配置
- 向量索引策略设计
- 与关系数据库的数据同步机制
- 向量检索性能优化
- 向量数据备份恢复方案

**技术要点**：
- Milvus Cluster/Standalone部署
- 索引类型选择（IVF、HNSW、Annoy）
- 数据同步策略（CDC/定时同步）
- 检索参数调优
- 存储优化（数据压缩、分区）

**交付物**：
- Milvus部署配置
- 索引策略文档
- 数据同步方案
- 性能优化报告
- 备份恢复方案

---

### 第五大类：应用服务与网关（1人负责）

#### 5.1 多租户网关与服务（负责人：网关架构师）
**工作内容**：
- API网关选型与部署（Kong/Istio）
- 基于租户的路由规则配置
- 租户级限流策略
- 多实例负载均衡配置
- 微服务间通信安全（mTLS）

**技术要点**：
- Kong Ingress Controller配置
- Istio VirtualService路由
- 限流算法（令牌桶/滑动窗口）
- 负载均衡策略
- 服务网格安全配置

**交付物**：
- 网关架构设计文档
- 路由配置清单
- 限流策略文档
- 负载均衡配置
- mTLS配置文档

---

### 第六大类：部署与运维（1人负责）

#### 6.1 部署与监控（负责人：运维工程师）
**工作内容**：
- CI/CD自动化部署流程
- 监控告警系统搭建（Prometheus + Grafana）
- 日志管理系统（ELK/Loki）
- 集群高可用设计
- 灾备方案制定

**技术要点**：
- GitLab CI/Jenkins Pipeline
- Prometheus指标采集
- Grafana仪表板配置
- ELK日志收集分析
- 多活架构设计

**交付物**：
- CI/CD配置文档
- 监控告警规则
- Grafana仪表板
- 日志管理规范
- 高可用架构文档

---

## 8人分工方案

### 人员职责矩阵

| 人员编号 | 角色 | 职责领域 | 主要任务 | 工作量占比 |
|---------|------|---------|---------|-----------|
| 人员1 | 身份认证架构师 | 身份认证与多租户 | Keycloak多租户设计、AD集成、身份映射 | 20% |
| 人员2 | 安全工程师 | K8s安全 | Secret管理、密钥管理、安全审计 | 15% |
| 人员3 | 数据安全工程师 | 数据访问控制 | 访问控制引擎、策略模块、权限判断 | 20% |
| 人员4 | 数据访问工程师 | 数据访问层 | ODBC封装、数据访问组件、性能优化 | 15% |
| 人员5 | 向量数据库工程师 | 向量数据库 | Milvus部署、向量检索、数据同步 | 10% |
| 人员6 | 网关架构师 | 网关与服务 | API网关、多租户路由、服务网格 | 10% |
| 人员7 | 运维工程师 | 部署运维 | 部署流程、监控告警、日志管理 | 5% |
| 人员8 | 全栈开发工程师 | 集成开发 | 前后端集成、API对接、测试支持 | 5% |

### 人员协作关系

```
人员1（身份认证） ←→ 人员2（安全） ←→ 人员3（数据安全）
     ↓                    ↓                    ↓
人员4（数据访问） ←→ 人员5（向量数据库） ←→ 人员6（网关）
     ↓                    ↓                    ↓
人员7（运维） ←→ 人员8（全栈）
```

---

## 关键技术难点解决方案

### 难点1：表级和列级访问控制（不改客户表结构）

#### 问题描述
客户要求不修改其数据表结构，但需要实现表级和列级的访问控制。

#### 推荐方案：Apache ShardingSphere + OPA组合

```
应用层 → ShardingSphere Proxy → OPA策略引擎 → 客户原始数据库
         (数据脱敏)              (策略决策)
```

#### 技术选型分析

| 方案 | 推荐指数 | 成熟度 | 优点 | 缺点 |
|-----|---------|--------|------|------|
| **Apache ShardingSphere** | ⭐⭐⭐⭐⭐ | 非常高 | 原生支持数据脱敏、透明集成、Apache顶级项目 | 配置相对复杂 |
| **ProxySQL** | ⭐⭐⭐⭐ | 高 | 性能优秀、配置灵活 | 主要支持MySQL、列级控制需复杂规则 |
| **OPA** | ⭐⭐⭐⭐ | 高 | 策略即代码、灵活强大、云原生友好 | 需要应用集成 |
| **Calcite** | ⭐⭐⭐ | 中等 | SQL标准兼容、轻量级 | 需要开发集成 |

#### 推荐架构：ShardingSphere Proxy + OPA

**ShardingSphere负责**：
- 数据脱敏（Column Masking）
- SQL解析和改写
- 数据库代理层
- 透明数据访问

**OPA负责**：
- 细粒度策略决策
- 访问控制规则
- 策略集中管理
- 审计日志

#### 实现架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        应用层                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              统一访问控制API接口                          │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│                    ShardingSphere Proxy层                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐ │
│  │  SQL解析    │  │  数据脱敏   │  │  连接池管理             │ │
│  └─────────────┘  └─────────────┘  └─────────────────────────┘ │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐ │
│  │  读写分离   │  │  路由规则   │  │  SQL审计日志            │ │
│  └─────────────┘  └─────────────┘  └─────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│                      OPA策略引擎层                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              Rego策略定义与决策                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              策略缓存（Redis）                           │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│                      数据源层                                    │
│  ┌─────────────────┐  ┌─────────────────┐  ┌────────────────┐  │
│  │  客户原始数据库  │  │  Milvus向量库   │  │  GaussDB       │  │
│  │  （不加任何列）  │  │  （DCPE加密）   │  │  （元数据）    │  │
│  └─────────────────┘  └─────────────────┘  └────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

#### ShardingSphere配置示例

**1. 数据脱敏规则配置**
```yaml
# sharding-config.yaml
rules:
  - tables:
      customer_info:
        columns:
          phone:
            encryptorName: phone_encryptor
            type: AES
          salary:
            encryptorName: salary_encryptor
            type: AES
          id_card:
            encryptorName: id_masking
            type: MASK
        queryWithCipherColumn: false

  encryptors:
    phone_encryptor:
      type: AES
      props:
        aes-key-value: your-aes-key
    salary_encryptor:
      type: AES
      props:
        aes-key-value: your-aes-key
    id_masking:
      type: MASK
      props:
        mask-character: "*"
        mask-start: 6
        mask-length: 8
```

**2. 列级访问控制配置**
```yaml
# column-access-rules.yaml
rules:
  - access_control:
      - table: customer_info
        columns:
          - name: phone
            roles:
              - admin: full_access
              - manager: read_only
              - user: masked
          - name: salary
            roles:
              - admin: full_access
              - manager: no_access
              - user: no_access
```

#### OPA策略配置示例

**1. Rego策略定义**
```rego
package data_access

# 允许访问的列
allow_column(table, column, role) {
    role == "admin"
    allow_table(table, role)
}

allow_column(table, column, role) {
    role == "manager"
    allow_table(table, role)
    not restricted_column[table][column]
}

allow_column(table, column, role) {
    role == "user"
    allow_table(table, role)
    public_column[table][column]
}

# 允许访问的表
allow_table(table, role) {
    role == "admin"
}

allow_table(table, role) {
    role == "manager"
    manager_allowed_tables[table]
}

allow_table(table, role) {
    role == "user"
    user_allowed_tables[table]
}

# 公共列（所有角色可访问）
public_column["customer_info"] = {"id", "name", "create_time"}

# 受限列（仅管理员可访问）
restricted_column["customer_info"] = {"salary", "id_card"}

# 管理员允许的表
manager_allowed_tables = {"customer_info", "order_info"}

# 普通用户允许的表
user_allowed_tables = {"customer_info"}
```

**2. OPA API调用**
```bash
# 策略决策请求
curl -X POST http://opa:8181/v1/data/data_access/allow \
  -H "Content-Type: application/json" \
  -d '{
    "input": {
      "table": "customer_info",
      "column": "salary",
      "role": "user"
    }
  }'

# 响应
{"result": false}
```

#### 技术实现要点

**1. 权限判断流程**
```
用户请求 → ShardingSphere解析 → OPA策略决策 → 数据脱敏 → 执行SQL → 返回结果
```

**2. 动态SQL构建**
```python
class SecureQueryBuilder:
    def __init__(self, opa_client, sharding_config):
        self.opa_client = opa_client
        self.sharding_config = sharding_config
    
    def build_secure_query(self, user, table, requested_columns):
        # 1. 获取用户角色和权限
        user_role = user.role
        tenant_id = user.tenant_id
        
        # 2. 调用OPA进行策略决策
        allowed_columns = []
        for column in requested_columns:
            decision = self.opa_client.check_access(
                table=table,
                column=column,
                role=user_role,
                tenant_id=tenant_id
            )
            if decision.allowed:
                if decision.masked:
                    allowed_columns.append(f"MASK({column})")
                else:
                    allowed_columns.append(column)
        
        # 3. 构建最终SQL
        if not allowed_columns:
            raise AccessDeniedException("无权限访问该表")
        
        query = f"""
            SELECT {', '.join(allowed_columns)}
            FROM {table}
            WHERE tenant_id = '{tenant_id}'
        """
        
        return self.sharding_config.execute(query)
```

**3. 数据脱敏函数**
```sql
-- ShardingSphere内置脱敏函数
SELECT 
    id,
    name,
    MASK(phone) as phone,           -- 手机号脱敏
    MASK(id_card, 6, 8) as id_card,  -- 身份证号脱敏
    salary                           -- 管理员可看到原始值
FROM customer_info
WHERE tenant_id = 'tenant_a';
```

#### 交付物
- ShardingSphere部署配置
- OPA策略配置
- 数据脱敏规则文档
- API接口文档
- 策略管理平台
- 性能测试报告

---

### 难点2：Milvus向量数据库集成（DCPE加密）

#### 问题描述
Milvus仅存储表头和非内容性数据，原始数据通过ODBC调用客户数据库。需要基于DCPE加密算法对关键价值数据和隐私原始数据进行向量化后的安全增强。

#### DCPE加密算法集成

**DCPE（Data Classification and Privacy Encryption）**：
- 关键价值数据：向量加密存储
- 隐私原始数据：脱敏后向量化
- 权限级别：基于向量相似度的访问控制

#### 实现架构

```
┌─────────────────────────────────────────────────────────────────┐
│                      数据处理层                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              DCPE加密引擎                                │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │   │
│  │  │  数据分类   │  │  隐私脱敏   │  │  向量加密       │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│                      Milvus向量库                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              向量索引层                                  │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐  │   │
│  │  │  加密向量   │  │  脱敏向量   │  │  权限向量       │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘  │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│                      访问控制层                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              权限验证与向量检索                          │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

#### DCPE加密实现

**1. 数据分类与加密策略**
```python
class DCPESecurityEngine:
    
    def classify_and_encrypt(self, data, sensitivity_level):
        """
        根据敏感级别进行分类和加密
        """
        if sensitivity_level == "critical":
            # 关键价值数据：完全加密存储
            return self.encrypt_critical_data(data)
        elif sensitivity_level == "private":
            # 隐私数据：脱敏后向量化
            return self.mask_and_vectorize(data)
        elif sensitivity_level == "internal":
            # 内部数据：仅向量化
            return self.vectorize(data)
        else:
            # 公开数据：直接存储
            return data
    
    def encrypt_critical_data(self, data):
        """
        关键数据加密：使用AES-256加密后向量化
        """
        # 1. AES加密
        encrypted = self.aes_encrypt(data)
        
        # 2. 生成加密向量
        encrypted_vector = self.generate_vector(encrypted)
        
        # 3. 生成权限向量（用于访问控制）
        permission_vector = self.generate_permission_vector(data)
        
        return {
            "encrypted_data": encrypted,
            "encrypted_vector": encrypted_vector,
            "permission_vector": permission_vector,
            "encryption_metadata": {
                "algorithm": "AES-256-GCM",
                "key_version": "v1",
                "timestamp": self.get_timestamp()
            }
        }
    
    def mask_and_vectorize(self, data):
        """
        隐私数据脱敏后向量化
        """
        # 1. 数据脱敏
        masked_data = self.apply_masking_rules(data)
        
        # 2. 生成脱敏向量
        masked_vector = self.generate_vector(masked_data)
        
        # 3. 生成隐私级别向量
        privacy_vector = self.generate_privacy_vector(data)
        
        return {
            "masked_data": masked_data,
            "masked_vector": masked_vector,
            "privacy_vector": privacy_vector,
            "masking_metadata": {
                "rules_applied": self.get_applied_rules(),
                "original_hash": self.hash_original(data)
            }
        }
```

**2. 向量访问控制**
```python
class VectorAccessController:
    
    def check_access(self, user, vector_request):
        """
        基于DCPE的向量访问控制
        """
        # 1. 获取用户权限级别
        user_level = self.get_user_permission_level(user)
        
        # 2. 获取请求数据的敏感级别
        data_level = self.get_data_sensitivity_level(vector_request)
        
        # 3. 权限级别比较
        if not self.has_access(user_level, data_level):
            return AccessDenied(
                reason=f"权限不足：用户级别 {user_level} < 数据级别 {data_level}"
            )
        
        # 4. 生成查询向量
        query_vector = self.generate_query_vector(
            vector_request.query,
            user_level
        )
        
        # 5. 执行向量检索
        results = self.milvus.search(
            collection_name="secure_vectors",
            query_vector=query_vector,
            filter_expression=f"permission_level <= {user_level}"
        )
        
        # 6. 解密返回结果
        decrypted_results = self.decrypt_results(results, user_level)
        
        return decrypted_results
    
    def has_access(self, user_level, data_level):
        """
        权限级别映射：
        1: 公开级别 - 可访问公开数据
        2: 内部级别 - 可访问内部和公开数据
        3: 机密级别 - 可访问机密、内部和公开数据
        4: 绝密级别 - 可访问所有数据
        """
        level_hierarchy = {
            "public": 1,
            "internal": 2,
            "confidential": 3,
            "top_secret": 4
        }
        
        return level_hierarchy.get(user_level, 0) >= level_hierarchy.get(data_level, 0)
```

**3. Milvus集合配置**
```yaml
# milvus-collection-config.yaml
collections:
  - name: secure_vectors
    description: 安全向量存储（DCPE加密）
    schema:
      fields:
        - name: id
          type: int64
          is_primary_key: true
        - name: encrypted_vector
          type: float_vector
          dim: 512
          description: 加密后的向量
        - name: permission_vector
          type: float_vector
          dim: 64
          description: 权限控制向量
        - name: sensitivity_level
          type: int
          description: "敏感级别：1-公开，2-内部，3-机密，4-绝密"
        - name: encryption_metadata
          type: varchar
          description: 加密元数据JSON
        - name: tenant_id
          type: varchar
          description: 租户ID
    index_params:
      - field_name: encrypted_vector
        index_type: HNSW
        metric_type: COSINE
        params:
          M: 16
          efConstruction: 200
      - field_name: permission_vector
        index_type: IVF_FLAT
        metric_type: COSINE
        params:
          nlist: 1024
```

#### 交付物
- DCPE加密引擎设计文档
- Milvus部署配置
- 向量访问控制策略
- 加密向量检索方案
- 性能优化报告

---

## 附录

### A. 技术选型建议

| 组件 | 推荐方案 | 备选方案 |
|-----|---------|---------|
| Keycloak | 22.x/23.x | 21.x |
| API网关 | Kong | Istio, Apigee |
| 缓存 | Redis | Memcached |
| 监控 | Prometheus + Grafana | Zabbix |
| 日志 | ELK | Loki |
| 密钥管理 | HashiCorp Vault | AWS KMS |
| **数据访问控制** | **Apache ShardingSphere + OPA** | ProxySQL, Calcite |
| 向量数据库 | Milvus | Qdrant, Weaviate |

### B. 开源数据访问控制方案对比

| 方案 | 类型 | 成熟度 | 列级安全 | 表级安全 | 部署简单性 | 性能 |
|-----|------|--------|---------|---------|-----------|------|
| **Apache ShardingSphere** | 数据库中间件 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **OPA** | 策略引擎 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **ProxySQL** | 数据库代理 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **Calcite** | SQL引擎 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |

### C. DCPE加密算法说明

**DCPE（Data Classification and Privacy Encryption）** 是一种数据安全增强方案：

- **数据分类**：根据敏感程度分为公开、内部、机密、绝密四个级别
- **隐私脱敏**：对隐私数据进行脱敏处理后向量化
- **向量加密**：关键数据加密后存储为向量
- **权限控制**：基于向量相似度的细粒度访问控制

**权限级别映射**：
```
1: 公开级别 - 可访问公开数据
2: 内部级别 - 可访问内部和公开数据
3: 机密级别 - 可访问机密、内部和公开数据
4: 绝密级别 - 可访问所有数据
```

### D. 参考文档

- [Keycloak官方文档](https://www.keycloak.org/documentation)
- [K8s Secret管理](https://kubernetes.io/docs/concepts/configuration/secret/)
- [Milvus官方文档](https://milvus.io/docs)
- [ODBC标准规范](https://docs.microsoft.com/en-us/sql/odbc/reference/odbc-specification)
- [Apache ShardingSphere官方文档](https://shardingsphere.apache.org/)
- [OPA官方文档](https://www.openpolicyagent.org/)
- [DCPE加密算法论文](https://arxiv.org/search/?query=DCPE+encryption)

---

**文档版本**：2.0
**创建日期**：2024年
**最后更新**：2026-02-01
**维护人员**：项目组
